#!/bin/bash

#  Copyright 2011-2014 Red Hat
#
#  This file is part of PressGang CCMS.
#
#  PressGang CCMS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  PressGang CCMS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with PressGang CCMS.  If not, see <http://www.gnu.org/licenses/>.

# This script runs once. It performs the following:
# 1. Lookup each locale file
# 2. Loop over the content spec IDS in the locale file
# 4. Rebuild the content spec
# 5. Build up an index page of all the content specs
#
# The script will only initiate as many concurrent rebuilds as the local PC has CPU cores.

# The location where info about last build times is stored
DOCBUILDER_DATA_DIR=/home/pressgang/.docbuilder
# The script to call to actually build the books
BOOK_BUILD_SCRIPT=/home/pressgang/DocBuilder2/build_books.sh
# The javascript file that is built up with each locale
JS_TMP_FILE=/tmp/data.js
# Locale build information directory
LANG_DATA_DIR=/home/pressgang/translations/
# Languages to build in
LANGS=("ja=ja-JP" "fr=fr-FR" "pt-BR=pt-BR" "de=de-DE" "es=es-ES" "zh-Hans=zh-CN" "it=it-IT" "ko=ko-KR" "ru=ru-RU" "zh-TW=zh-TW")
# Get the number of cores
CORE_COUNT=`grep -c ^processor /proc/cpuinfo`

# Perform a check to make sure that the build script is executable
if [[ ! -x "$BOOK_BUILD_SCRIPT" ]]
then
    echo "Build script '$BOOK_BUILD_SCRIPT' is not executable or doesn't exist"
    exit 1
fi

# Loop over each locale and build the books for that locale
for LOCALE in "${LANGS[@]}"
do
  IFS='=' read -ra ADDR <<< "$LOCALE"

  # Extract the language and Publican language
	BUILD_LANG=${ADDR[0]}
	PUBLICAN_LANG=${ADDR[1]}

  # Check that the build file exists
  BUILD_LANG_FILE="${LANG_DATA_DIR}${BUILD_LANG}.txt"
  if [[ ! -f "$BUILD_LANG_FILE" ]]
  then
    echo "Unable to find '${BUILD_LANG_FILE}', skipping ${BUILD_LANG}."
    continue
  fi

  echo "Starting to build ${BUILD_LANG} books."

	# Dump the HTML header boilderplate	
    echo "var TO_BE_SYNCED_LABEL = 'To Be Synced'; " > ${JS_TMP_FILE}
    echo "var OPEN_LINK_ID_REPLACE = '\${ID}';" >> ${JS_TMP_FILE}
    echo "var OPEN_LINK_LOCALE_REPLACE = '\${LOCALE}';" >> ${JS_TMP_FILE}
    echo "var OPEN_LINK = 'http://docbuilder.usersys.redhat.com/\${LOCALE}/\${ID}';" >> ${JS_TMP_FILE}
    echo "var UI_URL = 'pressgang-ccms-ui-next';" >> ${JS_TMP_FILE}
    echo "var EDIT_LINK = 'http://virt-ecs-01.lab.eng.bne.redhat.com:8080/pressgang-ccms-ui-next/#ContentSpecFilteredResultsAndContentSpecView;query;contentSpecIds=\${ID}';" >> ${JS_TMP_FILE}
    echo "var BASE_SERVER = 'virt-ecs-01.lab.eng.bne.redhat.com:8080';" >> ${JS_TMP_FILE}
	echo "var data = [" >> ${JS_TMP_FILE}

  # Read in each line of the build language file to get the Content Spec IDs to build
  while read CS_ID
  do
    # Check that the line isn't empty or a comment
    if [[ "$CS_ID" =~ ^#.*$ ]] || [ -z "$CS_ID" ]
    then
      continue
    fi

    #echo ${CS_ID}
	  CONTENT_SPEC=$(curl --silent http://skynet.usersys.redhat.com:8080/pressgang-ccms/rest/1/contentspec/get/json+text/${CS_ID})
	
	  TITLE=$(echo ${CONTENT_SPEC} | grep -Po '(?<="title":").*?(?=",)')
	  PRODUCT=$(echo ${CONTENT_SPEC} | grep -Po '(?<="product":").*?(?=",)')
	  VERSION=$(echo ${CONTENT_SPEC} | grep -Po '(?<="version":").*?(?=",)')
	
	  PRODUCT=${PRODUCT//\'/\\\'}
	  ESCAPED_PRODUCT=${PRODUCT// /_}
	  ESCAPED_PRODUCT=${ESCAPED_PRODUCT//[^A-Za-z0-9_.-]/}
	  TITLE=${TITLE//\'/\\\'}
	  ESCAPED_TITLE=${TITLE// /_}
	  ESCAPED_TITLE=${ESCAPED_TITLE//[^A-Za-z0-9_.-]/}

	  # Sleep until a core is free for another publican build
	  PUBLICAN_COUNT=$(ps -ef | grep -v grep | grep publican | wc -l)
	  CSPROCESSOR_COUNT=$(ps -ef | grep -v grep | grep csprocessor.jar | wc -l)
	  echo ${PUBLICAN_COUNT} instances of publican running.
	  echo ${CSPROCESSOR_COUNT} instances of csprocessor running. 
	
	  while [ $((${PUBLICAN_COUNT} + ${CSPROCESSOR_COUNT})) -ge ${CORE_COUNT} ]
	  do
		  echo "Sleeping until publican and csprocessor finish"
		  sleep 20;
		
		  PUBLICAN_COUNT=$(ps -ef | grep -v grep | grep publican | wc -l)
		  CSPROCESSOR_COUNT=$(ps -ef | grep -v grep | grep csprocessor.jar | wc -l)
		  echo ${PUBLICAN_COUNT} instances of publican running.
		  echo ${CSPROCESSOR_COUNT} instances of csprocessor running. 
	  done
	
	  CS_FILENAME=${DOCBUILDER_DATA_DIR}/${BUILD_LANG}/${CS_ID}
	  #echo $CS_FILENAME
	
	  # Create the data directory if it does not exist
	  if [ ! -d "${DOCBUILDER_DATA_DIR}/${BUILD_LANG}" ]
	  then
		  echo Data directory was not present, and was created.
		  mkdir -p ${DOCBUILDER_DATA_DIR}/${BUILD_LANG}
	  fi
	
	  # Check for the last time we recompiled the content spec
	  if [ -f ${CS_FILENAME} ]
	  then
		  echo "Last compile data was found for ${CS_ID}."
	
			date '+%Y-%m-%dT%k:%M:%S.000%z' > ${CS_FILENAME}
	  else
		  echo "Last compile data was not found for ${CS_ID} and was set to now."
	
		  date '+%Y-%m-%dT%k:%M:%S.000%z' > ${CS_FILENAME}
	  fi
	
	  LAST_COMPILE=$(head -n 1 ${CS_FILENAME})
	
	  # Add an entry to the index page
	  echo "{ idRaw: ${CS_ID}, id: '<a href=\"${CS_ID}\" target=\"_top\">${CS_ID}</a>', versionRaw: '${VERSION}', version: '<a href=\"${CS_ID}\"  target=\"_top\">${VERSION}</a>', productRaw: '${PRODUCT}', product: '<a href=\"${CS_ID}\" target=\"_top\">${PRODUCT}</a>', titleRaw: '${TITLE}', title: '<a href=\"${CS_ID}\"  target=\"_top\">${TITLE}</a>', pdfLink: '<a href=\"${CS_ID}/${ESCAPED_PRODUCT}-${VERSION}-${ESCAPED_TITLE}-${PUBLICAN_LANG}.pdf\">View PDF</a>', buildlog: '<a href=\"${CS_ID}/build.log\"><button>Build Log</button></a>' , publicanlog: '<a href=\"${CS_ID}/publican.log\"><button>Publican Log</button></a>', lastcompile: '${LAST_COMPILE}'}," >> ${JS_TMP_FILE}
	
	  # Build the book
	  echo Recompiling ${CS_ID}

	  ${BOOK_BUILD_SCRIPT} ${BUILD_LANG}${CS_ID} "${BUILD_LANG}=${PUBLICAN_LANG}=${CS_ID}" > /dev/null 2>&1 &	
	
	  #break

  done < $BUILD_LANG_FILE
	
  # Finish the index page, and copy to the www dir
  echo " ]; jQuery(function() {filterData(data)});" >> ${JS_TMP_FILE}

  # Create the html language directory if it does not exist
  if [ ! -d /var/www/html/${BUILD_LANG} ]
  then
	  echo "${BUILD_LANG} HTML directory was not present, and was created."
	  mkdir -p /var/www/html/${BUILD_LANG}
  fi

  rm -f /var/www/html/${BUILD_LANG}/data.js.old
  mv /var/www/html/${BUILD_LANG}/data.js /var/www/html/${BUILD_LANG}/data.js.old
  cp  ${JS_TMP_FILE} /var/www/html/${BUILD_LANG}/data.js
done

# Sleep until the builds have finished
PUBLICAN_COUNT=$(ps -ef | grep -v grep | grep publican | wc -l)
CSPROCESSOR_COUNT=$(ps -ef | grep -v grep | grep csprocessor.jar | wc -l)

WAIT_COUNT=0
while [ $((${PUBLICAN_COUNT} + ${CSPROCESSOR_COUNT})) -ge 1 ] && [ ${WAIT_COUNT} -le 5 ]
do
  echo "Waiting for builds to finish"
  sleep 20;

  PUBLICAN_COUNT=$(ps -ef | grep -v grep | grep publican | wc -l)
  CSPROCESSOR_COUNT=$(ps -ef | grep -v grep | grep csprocessor.jar | wc -l)
  WAIT_COUNT=$((${WAIT_COUNT} + 1))
done
